---
title: "Storyboards"
author: "Clover"
date: "20 February 2019"
output: 
    flexdashboard::flex_dashboard:
        storyboard: true
        theme: lumen
---

```{r}
# In order to use these packages, we need to install flexdashboard, plotly, and Cairo.
library(tidyverse)
library(plotly)
library(spotifyr)
source('spotify.R')
```

### Research quesion and Corpus

  - **Research Quesion**:
  1. The difference between songs of Rihanna and Beyonc, the queens of pop music.
  2. The characterist of pop-music.

  - **Corpus**: The selected artists are Rihanna and Beyonce.
  1. Rihanna:
      - 13 albums released. Excluding the edit,remix,live versions, there are 8 official albums with 106 observations in total. 
      - The album "a girl like me" obtain the lowest album popularity (pop=46), whereas the other 7 are within the range
  2. Beyounce:
      - 12 albums released. Excluding the edit,remix, live versions, there are 5 official albums with 84 observations in total.

  - **Statistical result:
  
  | Artist | album popularity mean | track popularity mean | standard deviation of track |
  |:-------:|:--------------------:|:---------------------:|:---------------------------:|
  | Rihanna | 66.6 |  41.9  | 14.2 |
  | Beyonce | 59.0 |  40.4  | 16.1 |
  
### Loudness, Popularity, Mode

```{r}
RihannaAll <- get_artist_audio_features('Rihanna')
Rihanna <- filter(RihannaAll, album_name %in% c('A Girl Like Me','ANTI','Good Girl Gone Bad','Loud','Music Of The Sun','Rated R','Talk That Talk','Unapologetic'))

BeyonceAll <- get_artist_audio_features('Beyonce')
Beyonce <- filter(BeyonceAll, album_name %in% c("4","B'Day","Dangerously In Love","I AM...SASHA FIERCE","BEYONCÃ‰ [Platinum Edition]"))

Dataset <-
Rihanna %>% mutate(artist = "Rihanna") %>% bind_rows(Beyonce %>% mutate(artist = "Beyonce"))

#graph
Dataset %>%                       # Start with awards.
ggplot(                         # Set up the plot.
  aes(
      x = loudness,
      y = track_popularity,
      size = danceability,
      colour = mode
      )
  ) +
geom_point() +               # Scatter plot.
geom_smooth(col="red") +
geom_rug(size = 0.001) +       # Add 'fringes' to show data distribution.
facet_wrap(~ artist) +     # Separate charts per playlist.
scale_x_continuous(          # Fine-tune the x axis.
      limits = c(-28, -2),
      breaks = c(-28, 4, -2),  # Use grid-lines for quadrants only.
      minor_breaks = NULL      # Remove 'minor' grid-lines.
      ) +
  scale_y_continuous(          # Fine-tune the y axis in the same way.
      limits = c(0, 80),
      breaks = c(0, 10, 80),
      minor_breaks = NULL
      ) +
  scale_colour_brewer(         # Use the Color Brewer to choose a palette.
      type = "qual",           # Qualitative set.
      palette = "Paired"       # Name of the palette is 'Paired'.
      ) +
  scale_size_continuous(       # Fine-tune the sizes of each point.
      trans = "exp",           # Use an exp transformation to emphasise loud.
      guide = "none"           # Remove the legend for size.
      ) +
  theme_light() +              # Use a simpler them.
  labs(                        # Make the titles nice.
      x = "loudness",
      y = "track_popularity",
      size = "danceability",
      colour = "Mode"
      )

```

***

  - Rihanna prefer major songs, whereas Beyonce prefer minor songs.
  - 2 outliers in beyonce songs because of low loudness. 
  - A louder song from Rihanna gained more popularity which is contraindicated to Beyonce.


### the most popular song of both actirsts

```{r}
get_tidy_audio_analysis <- function(track_uri, ...) 
{
  get_track_audio_analysis(track_uri, ...) %>% 
    list %>% transpose %>% as_tibble %>% 
    mutate_at(vars(meta, track), . %>% map(as_tibble)) %>% 
    unnest(meta, track) %>% 
    select(
      analyzer_version,
      duration,
      contains('fade'),
      ends_with('confidence'),
      bars:segments) %>% 
    mutate_at(
      vars(bars, beats, tatums, sections), 
      . %>% map(bind_rows)) %>% 
    mutate(
      segments =
        map(
          segments,
          . %>% 
            transpose %>% as_tibble %>% 
            unnest(.preserve = c(pitches, timbre)) %>% 
            mutate(
              pitches = 
                map(
                  pitches, 
                  . %>% 
                    flatten_dbl %>% 
                    set_names(
                      c( 
                        'C', 'C#|Db', 'D', 'D#|Eb', 
                        'E', 'F', 'F#|Gb', 'G',
                        'G#|Ab', 'A', 'A#|Bb', 'B'))),
              timbre = 
                map(
                  timbre,
                  . %>% 
                    flatten_dbl %>% 
                    set_names(
                      c(
                        'c1', 'c2', 'c3', 'c4', 
                        'c5', 'c6', 'c7', 'c8',
                        'c9', 'c10', 'c11', 'c12'))))))
}
#' Normalise vectors for Computational Musicology.
#'
#' We use a number of normalisation strategies in Computational Musicology.
#' This function brings them together into one place, along with common
#' alternative names.
compmus_normalise <- compmus_normalize <- function(v, method = "euclidean")
{
  ## Supported functions
  
  harmonic  <- function(v) v * sum(1 / abs(v))
  manhattan <- function(v) v / sum(abs(v))
  euclidean <- function(v) v / sqrt(sum(v^2))
  chebyshev <- function(v) v / max(abs(v))
  clr       <- function(v) {lv <- log(v); lv - mean(lv)}
  
  ## Method aliases
  
  METHODS <-
    list(
      harmonic  = harmonic,
      manhattan = manhattan,
      L1        = manhattan,
      euclidean = euclidean,
      L2        = euclidean,
      chebyshev = chebyshev,
      maximum   = chebyshev,
      aitchison = clr,
      clr       = clr)
  
  ## Function selection
  
  
  if (!is.na(i <- pmatch(method, names(METHODS))))
    METHODS[[i]](v)
  else 
    stop('The method name is ambiguous or the method is unsupported.')
}

#' Compute pairwise distances for Computational Musicology in long format.
#'
#' We use a number of distance measures in Computational Musicology.
#' This function brings them together into one place, along with common
#' alternative names. It is designed for convenience, not speed.
compmus_long_distance <- function(xdat, ydat, feature, method = "euclidean")
{
  
  feature <- enquo(feature)
  
  ## Supported functions
  
  manhattan <- function(x, y) sum(abs(x - y))
  euclidean <- function(x, y) sqrt(sum((x - y) ^ 2))
  chebyshev <- function(x, y) max(abs(x - y))
  pearson   <- function(x, y) 1 - cor(x, y)
  cosine    <- function(x, y)
  {
    1 - sum(compmus_normalise(x, "euc") * compmus_normalise(y, "euc"))
  }
  angular   <- function(x, y) 2 * acos(1 - cosine(x, y)) / pi
  aitchison <- function(x, y)
  {
    euclidean(compmus_normalise(x, "clr"), compmus_normalise(y, "clr"))
  }
  
  ## Method aliases
  
  METHODS <-
    list(
      manhattan   = manhattan,
      cityblock   = manhattan,
      taxicab     = manhattan,
      L1          = manhattan,
      totvar      = manhattan,
      euclidean   = euclidean,
      L2          = euclidean,
      chebyshev   = chebyshev,
      maximum     = chebyshev,
      pearson     = pearson,
      correlation = pearson,
      cosine      = cosine,
      angular     = angular,
      aitchison   = aitchison)
  
  ## Function selection
  
  if (!is.na(i <- pmatch(method, names(METHODS))))
    bind_cols(
      crossing(
        xdat %>% select(xstart = start, xduration = duration),
        ydat %>% select(ystart = start, yduration = duration)),
      xdat %>% select(x = !!feature) %>% 
        crossing(ydat %>% select(y = !!feature)) %>% 
        transmute(d = map2_dbl(x, y, METHODS[[i]])))
  else 
    stop('The method name is ambiguous or the method is unsupported.')
}

compmus_gather_chroma <- function(data)
{
  data %>% 
    mutate(pitches = map(pitches, bind_rows)) %>% unnest(pitches) %>% 
    gather("pitch_class", "value", C:B) %>% 
    mutate(pitch_class = fct_shift(factor(pitch_class), 3))
}

# beyonce
Beyonce_Dangerouslyinlove <- 
  get_tidy_audio_analysis('0KFuXEdOp5QfIfxHR6TJSm') %>% 
  select(segments) %>% unnest(segments) %>% 
  select(start, duration, pitches)

Beyonce_Dangerouslyinlove %>% 
  mutate(pitches = map(pitches, compmus_normalise, 'chebyshev')) %>% 
  compmus_gather_chroma %>% 
  ggplot(
    aes(
      x = start + duration / 2, 
      width = duration, 
      y = pitch_class, 
      fill = value)) + 
  geom_tile() +
  labs(x = 'Time (s)', y = NULL, fill = 'Magnitude') +
  theme_minimal() + 
  ggtitle("Dangerously in love - Beyonce")

#rihanna
Rihanna_PondeReplay <- 
  get_tidy_audio_analysis('4TsmezEQVSZNNPv5RJ65Ov') %>% 
  select(segments) %>% unnest(segments) %>% 
  select(start, duration, pitches)

Rihanna_PondeReplay %>% 
  mutate(pitches = map(pitches, compmus_normalise, 'chebyshev')) %>% 
  compmus_gather_chroma %>% 
  ggplot(
    aes(
      x = start + duration / 2, 
      width = duration, 
      y = pitch_class, 
      fill = value)) + 
  geom_tile() +
  labs(x = 'Time (s)', y = NULL, fill = 'Magnitude') +
  theme_minimal() +
  ggtitle("Pon de replay - Rihanna")
```

***

Do not understand this code well. 

I selected 2 most popular song of both artists to practice. I cannot understand why from the Spotify API, Pon de Replay by Rihanna is in G major but the graph shows it is not in G major obvisouly. maybe there is any way to improve the result?